diff --git a/gcmm/loader.py b/gcmm/loader.py
index d0b5e01..6284013 100644
--- a/gcmm/loader.py
+++ b/gcmm/loader.py
@@ -19,17 +19,28 @@ class HMMSubset(object):
         self.index = index
 
         # get hmm build results from target directory
-        cmd = "find {} -name hmmbuild.input* -type f".format(path)
+        cmd = "find {} -maxdepth 1 -name hmmbuild.input* -type f".format(path)
         #Configs.debug("Command used: {}".format(cmd))
         self.alignment_path = os.path.abspath(
                 os.popen(cmd).read().split('\n')[0])
-        self.alignment = Alignment()
-        self.alignment.read_file_object(self.alignment_path)
+        #self.alignment = Alignment()
+        #self.alignment.read_file_object(self.alignment_path)
 
         # also get the hmm model path
-        cmd = "find {} -name hmmbuild.model.* -type f".format(path)
+        cmd = "find {} -maxdepth 1 -name hmmbuild.model.* -type f".format(path)
         #Configs.debug("Command used: {}".format(cmd))
-        self.hmm_model_path = os.popen(cmd).read().split('\n')[0]
+        self.hmm_model_path = os.path.abspath(
+                os.popen(cmd).read().split('\n')[0])
+
+        self.num_taxa = 0
+        _map = {}
+        with open(self.hmm_model_path, 'r') as f:
+            lines = f.read().split('\n')[:15]
+            for line in lines:
+                key, val = line.split()[0], ''.join(line.split()[1:])
+                if key == 'NSEQ':
+                    self.num_taxa = int(val)
+                    break
 
 '''
 Initialize global lock for writing to log file
@@ -89,17 +100,23 @@ def writeSubQueries(unaligned, outdir, num_seq, num_subset, pool):
 '''
 Helper function to load one alignment subset
 '''
-def getOneAlignmentSubset(align_dir):
+def getOneAlignmentSubset(lock, align_dir):
     this_dict = {}
     index = int(align_dir.split('/')[-1].split('_')[2])
     this_dict[index] = HMMSubset(align_dir, index) 
-    print('getting index {}'.format(index))
+    lock.acquire()
+    try:
+        Configs.debug('Finished dealing with subset #{} from {}'.format(
+            index, align_dir))
+    finally:
+        lock.release()
+
     return this_dict
 
 '''
 Load in UPP decomposition output subsets
 '''
-def getAlignmentSubsets(path, pool):
+def getAlignmentSubsets(path, lock, pool):
     cmd = "find {} -name A_0_* -type d".format(path)
     #Configs.debug("Command used: {}".format(cmd))
     align_dirs = os.popen(cmd).read().split('\n')[:-1]
@@ -107,7 +124,8 @@ def getAlignmentSubsets(path, pool):
 
     # create an AlignmentSubset object for each align_dir
     index_to_hmm = {}
-    all_dicts = list(pool.map(getOneAlignmentSubset, align_dirs))
+    func = partial(getOneAlignmentSubset, lock)
+    all_dicts = list(pool.map(func, align_dirs))
     for d in all_dicts:
         index_to_hmm.update(d)
     #for align_dir in align_dirs:
@@ -143,14 +161,11 @@ MP version of reading in and ranking bitscores from HMM subsets (from UPP)
 def readAndRankBitscoreMP(index_to_hmm, renamed_taxa, lock, pool):
     ranks = defaultdict(list)
     total_num_models = len(index_to_hmm)
-    #l = Lock()
+    Configs.log('Reading and ranking bit-scores from HMMSearch files')
 
     # submit jobs to Pool
-    #pool = Pool(Configs.num_cpus, initializer=init_lock_loader, initargs=(l,))
     func = partial(readHMMSearch, lock, total_num_models)
     all_subset_ranks = list(pool.map(func, index_to_hmm.values()))
-    #pool.close()
-    #pool.join()
 
     # merge all MP results
     for subset_ranks in all_subset_ranks:
@@ -215,7 +230,7 @@ def loadSubQueries(lock, pool):
                                     len(unaligned), num_subset, pool)
  
     # 1.2) read in all HMMSearch results (from UPP)
-    index_to_hmm = getAlignmentSubsets(Configs.hmmdir, pool)
+    index_to_hmm = getAlignmentSubsets(Configs.hmmdir, lock, pool)
 
     # 1.3) read and rank bitscores
     #ranked_bitscore = readAndRankBitscore(index_to_hmm)
